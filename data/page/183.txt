编码是信息从一种形式或格式转换为另一种形式的过程，也称为计算机编程语言的代码简称编码。用预先规定的方法将文字、数字或其它对象编成数码，或将信息、数据转换成规定的电脉冲信号。编码在电子计算机、电视、遥控和通讯等方面广泛使用。编码是信息从一种形式或格式转换为另一种形式的过程。解码，是编码的逆过程。
在计算机硬件中，编码（coding）是指用代码来表示各组数据资料，使其成为可利用计算机进行处理和分析的信息。代码是用来表示事物的记号，它可以用数字、字母、特殊的符号或它们之间的组合来表示
将数据转换为代码或编码字符，并能译为原数据形式。是计算机书写指令的过程，程序设计中的一部分。在地图自动制图中，按一定规则用数字与字母表示地图内容的过程，通过编码，使计算机能识别地图的各地理要素。
n位二进制数可以组合成2的n次方个不同的信息，给每个信息规定一个具体码组，这种过程也叫编码。
数字系统中常用的编码有两类，一类是二进制编码，另一类是十进制编码。
GB编码标准中，比较常用的是GB2312和GBK两种，GB2312是GBK的一个子集，GB2312编码范围是 0xA1A1 - 0xFEFE ，如果纯粹的 GB2312编码，处理起来是十分简单的，但处理GBK字符集时有些小的提示，先说说GBK编码的标准吧：
GBK 采用双字节表示，总体编码范围为 8140-FEFE，首字节在 81-FE 之间，尾字节在 40-FE 之间，剔除 xx7F 一条线。总计 23940 个码位，共收入 21886 个汉字和图形符号，其中汉字（包括部首和构件）21003 个，图形符号 883 个。
1. 汉字区。包括：
a. GB 2312 汉字区。即 GBK/2: B0A1-F7FE。收录 GB 2312 汉字 6763 个，按原顺序排列。
b. GB 13000.1 扩充汉字区。包括：
(1) GBK/3: 8140-A0FE。收录 GB 13000.1 中的 CJK 汉字 6080 个。
(2) GBK/4: AA40-FEA0。收录 CJK 汉字和增补的汉字 8160 个。
CJK 汉字在前，按 UCS 代码大小排列；增补的汉字（包括部首和构件）在后，按《康熙字典》的页码/字位排列。
2. 图形符号区。包括：
a. GB 2312 非汉字符号区。即 GBK/1: A1A1-A9FE。其中除 GB 2312 的符号外，
还有 10 个小写罗马数字和 GB 12345 增补的符号。计符号 717 个。
b. GB 13000.1 扩充非汉字区。即 GBK/5: A840-A9A0。BIG-5 非汉字符号、结构符和“○”排列在此区。计符号 166 个。
3. 用户自定义区：分为(1)(2)(3)三个小区。
(1) AAA1-AFFE，码位 564 个。
(2) F8A1-FEFE，码位 658 个。
(3) A140-A7A0，码位 672 个。
第(3)区尽管对用户开放，但限制使用，因为不排除未来在此区域增补新字符的可能性。
这里有几个小技巧：
一、在php中，字符编码是按所发送的编码为准的，因此使用的就是用户输入的编码，不会自动改变，但在asp中，默认的编码是unicode，这样我们很容易就能得到gbk-&gt;unicode的编码对照表，这样即使在毫无基础库的情况下也能很容易的实现gbk到utf-8的转换了；
二、由于GBK是高位最低数值是0x40，即是64，因此，有时候组织一些涉及中文的字串时，分割字符最好用64之前的ascii码，这样在任意情况下替换或分割都不会出现乱码，比较常用的是 ","、";"、":"、" "、" "、" "，这些字符永远都不会给gb编码添乱。
我们日常接触到的文件分ASCII和Binary两种。ASCII是“美国信息交换标准编码”的英文字头缩写，可称之为“美标”。美标规定了用从0到127的128个数字来代表信息的规范编码，其中包括33个控制码，一个空格码，和94个形象码。形象码中包括了英文大小写字母，阿拉伯数字，标点符号等。我们平时阅读的英文电脑文本，就是以形象码的方式传递和存储的。美标是国际上大部分大小电脑的通用编码。
然而电脑中的一个字符大都是用一个八位数的二进制数字表示。这样每一字符便可能有256个不同的数值。由于美标只规定了128个编码，剩下的另外128个数码没有规范，各家用法不一。另外美标中的33个控制码，各厂家用法也不尽一致。这样我们在不同电脑间交换文件的时候，就有必要区分两类不同的文件。第一类文件中每一个字都是美标形象码或空格码。这类文件称为“美标文本文件”(ASCII Text Files)，或略为“文本文件”，通常可在不同电脑系统间直接交换。第二类文件，也就是含有控制码或非美标码的文件，通常不能在不同电脑系统间直接交换。这类文件有一个通称，叫“二进制文件”(Binary Files)。
“国标”是“中华人民共和国国家标准信息交换用汉字编码”的简称。国标表（基本表）把七千余汉字、以及标点符号、外文字母等，排成一个94行、94列的方阵。方阵中每一横行叫一个“区”，每个区有九十四个“位”。一个汉字在方阵中的坐标，称为该字的“区位码”。例如“中”字在方阵中处于第54区第48位，它的区位码就是5448。
其实94这个数字。它是美标中形象码的总数。国标表沿用这个数字，本意大概是要用两个美标形象符代表一个汉字。由于美标形象符的编码是从33到126，汉字区位码如果各加上32，就会与美标形象码的范围重合。如上例“中”字区、位码加上32后，得86,80。这两个数字的十六进制放在一起得5650，称为该字的“国标码”，而与其相对应的两个美标符号，VP，也就是“中”字的“国标符”了。
这样就产生了一个如何区分国标符与美标符的问题。在一个中英文混用的文件里，“VP”到底代表“中”字呢，还是代表某个英文字头缩写？电子工业部第六研究所开发CCDOS的时候，使用了一个简便的解决方案：把国标码的两个数字各加上128，上升到非美标码的位置。（改变后的国标码，习惯上仍叫“国标”。）
这个方案固然解决了原来的问题，可是新的问题随之产生。中文文件成了“二进制文件”，既不能可靠地在不同电脑系统间交换，也不与市场上大部分以美标符号为设计对象的软件兼容。
为了区分以上两种“国标”，我们把原与美标形象码重合的国标码称为“纯国标” ，而把CCDOS加上128的国标码称为“准国标”。
GBK码是GB码的扩展字符编码，对多达2万多的简繁汉字进行了编码，简体版的Win95和Win98都是使用GBK作系统内码。
从实际运用来看，微软自win95简体中文版开始，系统就采用GBK代码，它包括了TrueType宋体、黑体两种GBK字库（北京中易电子公司提供），可以用于显示和打印，并提供了四种GBK汉字的输入法。此外，浏览器IE4.0简体、繁体中文版内部提供了一个GBK-BIG5代码双向转换功能。此外，微软公司为IE提供的语言包中，简体中文支持（Simplified Chinese Language Support Kit）的两种字库宋体、黑体，也是GBK汉字（珠海四通电脑排版系统开发公司提供）。其他一些中文字库生产厂商，也开始提供TrueType或PostScript GBK字库。
许多外挂式的中文平台，如南极星、四通利方（Richwin）等，提供GBK码的支持，包括字库、输入法和GBK与其他中文代码的转化器。
互联网方面，许多网站网页使用GBK代码。
但是多数搜索引擎都不能很好的支持GBK汉字搜索，大陆地区的搜索引擎有些能不完善的支持GBK汉字检索。
其实，GBK是又一个汉字编码标准，全称《汉字内码扩展规范》（Chinese Internatial Code Specification），1995年颁布。GB是国标，K是汉字“扩展”的汉语拼音第一个字母。
GBK向下与GB-2312编码兼容，向上支持ISO 10646.1国际标准，是前者向后者过渡的一个承启标准。
GBK规范收录了ISO 10646.1中的全部CJK汉字和符号，并有所补充。具体包括：GB 2312中的全部汉字、非汉字符号；GB 13000.1中的其他CJK汉字。以上合计20902个GB化汉字；《简化总表中》未收入GB 13000.1的52个汉字；《康熙字典》以及《辞海》中未被收入GB 13000.1的28个部首及重要构件；13个汉字结构符；BIG-5中未被GB 2312收入、但存在于GB 13000.1的139个图形符号；GB 12345增补的6个拼音符号；GB 12345增补的19个竖排图形符号（GB 12345较GB 2312增补竖排标点符号29个，其中10个未被GB 13000.1收入，故GBK亦不收）；从GB 13000.1的CJK兼容区挑选出的21个汉字；GB 13000.1收入的31个IBM OS/2专用符号。GBK亦采用双字节表示，总体编码范围为0x8140~0xFEFE之间，首字节在0x81~0xFE之间，尾字节在0x40~0xFE之间，剔除0x××7F一条线，总计23940个码位，共收入21886个汉字和图形符号，其中汉字（包括部首和构件）21003个，图形符号883个。
BIG5码是针对繁体汉字的汉字编码，在台湾、香港的电脑系统中得到普遍应用。BIG5码的编码范围参考下文。
HZ 码是中国留学生为了使汉字信息能在网络上直接传送而产生的。因目前大多数 （西方）网络系统为7位，最高位被屏蔽掉，因此 GB 码无法被直接传输，HZ 码是为了达到在7位网络系统中直接传递汉字信息的目的而规范的。
“HZ”方案的特点，是以“纯国标”的中文与美标码混用。那么“HZ”是怎样区分国标符和美标符的呢？答案其实也很简单：当一串美标码中间插入一段国标码的时候，我们便在国标码的前面加上~，后面加上~。这些附加码分别叫“逃出码”和“逃入码”。 由于这些附加码本身也是美标形象码，整个文件就俨然是一个美标文本文件，可以安然地 在电脑网上传递，也和大部分英文文本处理软件兼容。
ISO-2022是国际标准组织（ISO）为各种语言字符制定的编码标准。采用二个字节编码，其中汉语编码称ISO-2022 CN，日语、韩语的编码分别称JP、KR。一般将三者合称CJK码。CJK码主要在Internet网络中使用。
1993年，国际标准ISO10646 定义了通用字符集(Universal Character Set, UCS)。 UCS 是所有其他字符集标准的一个超集。它保证与其他字符集是双向兼容的。就是说， 如果你将任何文本字符串翻译到 UCS格式，然后再翻译回原编码, 你不会丢失任何信息。
UCS 包含了用于表达所有已知语言的字符。不仅包括拉丁语，希腊语，斯拉夫语，希伯来语,阿拉伯语，亚美尼亚语和乔治亚语的描述， 还包括中文，日文和韩文这样的象形文字，以及平假名，片假名，孟加拉语,旁遮普语果鲁穆奇字符(Gurmukhi)，泰米尔语， 印.埃纳德语(Kannada)，Malayalam，泰国语， 老挝语， 汉语拼音(Bopomofo)， Hangul，Devangari，Gujarati， Oriya，Telugu 以及其它语种。对于还没有加入的语言, 由于正在研究怎样在计算机中最好地编码它们， 因而最终它们都将被加入。这些语言包括Tibetian，高棉语，Runic(古代北欧文字)，埃塞俄比亚语， 其他象形文字，以及各种各样的印-欧语系的语言，还包括挑选出来的艺术语言比如 Tengwar，Cirth 和克林贡语(Klingon)。UCS 还包括大量的图形的，印刷用的，数学用的和科学用的符号，包括所有由 TeX，Postscript，MS-DOS，MS-Windows， Macintosh， OCR字体， 以及许多其他字处理和出版系统提供的字符。
ISO 10646 定义了一个 31 位的字符集。 然而， 在这巨大的编码空间中, 迄今为止只分配了前 65534 个码位 (0x0000 到 0xFFFD)。这个UCS的16位子集称为基本多语言面 (Basic Multilingual Plane, BMP)。 将被编码在16位BMP以外的字符都属于非常特殊的字符(比如象形文字), 且只有专家在历史和科学领域里才会用到它们。按当前的计划， 将来也许再也不会有字符被分配到从0x000000到0x10FFFF这个覆盖了超过100万个潜在的未来字符的 21 位的编码空间以外去了。ISO 10646-1标准第一次发表于1993年, 定义了字符集与 BMP 中内容的架构。定义 BMP以外的字符编码的第二部分 ISO 10646-2 正在准备中， 但也许要过好几年才能完成。新的字符仍源源不断地加入到 BMP 中, 但已经存在的字符是稳定的且不会再改变了。
UCS 不仅给每个字符分配一个代码， 而且赋予了一个正式的名字。表示一个 UCS 或 Unicode 值的十六进制数, 通常在前面加上 “U+”， 就象U+0041 代表字符“拉丁大写字母A”。UCS字符U+0000到U+007F 与 US-ASCII(ISO 646) 是一致的， U+0000 到 U+00FF 与 ISO8859-1(Latin-1) 也是一致的。从 U+E000 到 U+F8FF，已经BMP 以外的大范围的编码是为私用保留的。
1993年，ISO10646中定义的USC-4 (Universal Character Set) ，使用了4 个字节的宽度以容纳足够多的相当可观的空间，但是这个过于肥胖的字符标准在当时乃至21世纪都有其不现实的一面，就是会过分侵占存储空间并影响信息传输的效率。 与此同时，Unicode 组织于约 10 年前以 Universal, Unique和Uniform 为主旨也开始开发一个16位字符标准， 为避免两种16位编码的竞争，1992年两家组织开始协商，以期折衷寻找共同点，这就是今天的 UCS-2 (BMP，Basic Multilingual Plane，16bit) 和Unicode，但它们仍然是不同的方案。
Unicode
关于Unicode我们需要追溯一下它产生的渊源。
当计算机普及到东亚时，遇到了使用表意字符而非字母语言的中、日、韩等国家。在这些国家使用的语言中常用字符多达几千个，而原来字符采用的是单字节编码，一张代码页中最多容纳的字符只有2^8=256个，对于使用表意字符的语言是在无能为力。既然一个字节不够，自然人们就采用两个字节，所有出现了使用双字节编码的字符集(DBCS)。不过双字节字符集中虽然表意字符使用了两个字节编码，但其中的ASCII码和日文片假名等仍用单字节表示，如此一来给程序员带来了不小的麻烦，因为每当涉及到DBCS字符串的处理时，总是要判断当中的一个字节到底表示的是一个字符还是半个字符，如果是半个字符，那是前一半还是后一半？由此可见DBCS并不是一种非常好的解决方案。
人们在不断寻找这更好的字符编码方案，最后的结果就是Unicode诞生了。Unicode其实就是宽字节字符集，它对每个字符都固定使用两个字节即16位表示，于是当处理字符时，不必担心只处理半个字符。
Unicode在网络、Windows系统和很多大型软件中得到应用。
编码(Encoding)在认知上是解释传入的刺激的一种基本知觉的过程。技术上来说，这是一个复杂的、多阶段的转换过程，从较为客观的感觉输入（例如光、声）到主观上有意义的体验。
字符编码(Character encoding)是一套法则，使用该法则能够对自然语言的字符的一个集合（如字母表或音节表），与其他东西的一个集合（如号码或电脉冲）进行配对。
文字编码(Text encoding)使用一种标记语言来标记一篇文字的结构和其他特征，以方便计算机进行处理。
语义编码(Semantics encoding)，以正式语言乙对正式语言甲进行语义编码，即是使用语言乙表达语言甲所有的词汇（如程序或说明）的一种方法。
电子编码(Electronic encoding)是将一个信号转换成为一个代码，这种代码是被优化过的以利于传输或存储。转换工作通常由一个编解码器完成。
PCM 脉冲编码调制是Pulse Code Modulation的缩写。（又叫脉冲编码调制）：数字通信的编码方式之一。主要过程是将话音、图像等模拟信号每隔一定时间进行取样，使其离散化，同时将抽样值按分层单位四舍五入取整量化，同时将抽样值按一组二进制码来表示抽样脉冲的幅值。
神经编码(Neural encoding)是指信息在神经元中被如何描绘的方法。
记忆编码(Memory encoding)是把感觉转换成记忆的过程。
加密(Encryption)是为了保密而对信息进行转换的过程。
译码(Transcoding)是将编码从一种格式转换到另一种格式的过程。
码转换轻松实现
一、利用iconv函数族进行编码转换
在LINUX上进行编码转换时，既可以利用iconv函数族编程实现,还可以利用iconv命令去实现，只不过后者是针对文件的,也就是将指定文件从一种编码转换为另一种编码。
iconv函数族的头文件是iconv.h，使用前需包含之。
#include &lt;iconv.h&gt;
iconv函数族有三个函数，原型如下：
(1) iconv_t iconv_open(const char *tocode, const char *fromcode)
此函数说明将要进行哪两种编码的转换，tocode是目标编码，fromcode是原编码，该函数返回一个转换句柄，供以下两个函数使用。
(2)size_ticonv(iconv_t cd，char **inbuf，size_t *inbytesleft，char **outbuf，size_t *outbytesleft)
此函数从inbuf中读取字符，转换后输出到outbuf中，inbytesleft用以记录还未转换的字符数，outbytesleft用以记录输出缓冲的剩余空间。 (3) int iconv_close(iconv_t cd)
此函数用于关闭转换句柄,释放资源。
例子1： 用C语言实现的转换示例程序
/* f.c ：代码转换示例C程序 */
#include &lt;iconv.h&gt;
#define OUTLEN 255
main()
{
char *in_utf8 = "姝e?ㄥ??瑁?"
char *in_gb2312 = "正在安装"
char out
//unicode码转为gb2312码
rc = u2g(in_utf8,strlen(in_utf8),out,OUTLEN)
printf("unicode--&gt;gb2312 out=%sn",out)
//gb2312码转为unicode码
rc = g2u(in_gb2312,strlen(in_gb2312),out,OUTLEN)
printf("gb2312--&gt;unicode out=%sn",out)
}
//代码转换：从一种编码转为另一种编码
int code_convert(char *from_charset,char *to_charset,char *inbuf,int inlen,char *outbuf,int outlen)
{
iconv_t cd;
int rc;
char **pin = &amp;inbuf;
char **pout = &amp;outbuf;
cd = iconv_open(to_charset,from_charset);
if (cd==0) return -1;
memset(outbuf,0,outlen);
if (iconv(cd,pin,&amp;inlen,pout,&amp;outlen)==-1) return -1;
iconv_close(cd);
return 0;
}
//UNICODE码转为GB2312码
int u2g(char *inbuf,int inlen,char *outbuf,int outlen)
{
return code_convert("utf-8","gb2312",inbuf,inlen,outbuf,outlen);
}
//GB2312码转为UNICODE码
int g2u(char *inbuf,size_t inlen,char *outbuf,size_t outlen)
{
return code_convert("gb2312","utf-8",inbuf,inlen,outbuf,outlen);
}
例子2: 用C++语言实现的转换示例程序
/* f.cpp : 代码转换示例C++程序 */
#include &lt;iconv.h&gt;
#include &lt;iostream&gt;
#define OUTLEN 255
using namespace std;
// 代码转换操作类
class CodeConverter {
private:
iconv_t cd;
public:
// 构造
CodeConverter(const char *from_charset,const char *to_charset) {
cd = iconv_open(to_charset,from_charset;
}
// 析构
~CodeConverter() {
iconv_close(cd);
}
// 转换输出
int convert(char *inbuf,int inlen,char *outbuf,int outlen) {
char **pin = &amp;inbuf;
char **pout = &amp;outbuf;
memset(outbuf,0,outlen);
return iconv(cd,pin,(size_t *)&amp;inlen,pout,(size_t *)&amp;outlen);
}
};
int main(int argc, char **argv)
{
char *in_utf8 = "姝e?ㄥ??瑁?";
char *in_gb2312 = "正在安装";
char out;
// utf-8--&gt;gb2312
CodeConverter cc = CodeConverter("utf-8","gb2312");
cc.convert(in_utf8,strlen(in_utf8),out,OUTLEN);
cout &lt;&lt; "utf-8--&gt;gb2312 in=" &lt;&lt; in_utf8 &lt;&lt; ",out=" &lt;&lt; out &lt;&lt; endl;
// gb2312--&gt;utf-8
CodeConverter cc2 = CodeConverter("gb2312","utf-8");
cc2.convert(in_gb2312,strlen(in_gb2312),out,OUTLEN);
cout &lt;&lt; "gb2312--&gt;utf-8 in=" &lt;&lt; in_gb2312 &lt;&lt; ",out=" &lt;&lt; out &lt;&lt; endl;
}
二、利用iconv命令进行编码转换
LINUX上进行编码转换时，既可以利用iconv函数族编程实现,也可以利用iconv命令来实现，只不过后者是针对文件的,即将指定文件从一种编码转换为另一种编码。
iconv命令用于转换指定文件的编码，默认输出到标准输出设备,亦可指定输出文件。
用法： iconv
有如下选项可用：
输入/输出格式规范：
-f, --from-code=名称 原始文本编码
-t, --to-code=名称 输出编码
信息：
-l, --list 列举所有已知的字符集
输出控制：
-c 从输出中忽略无效的字符
-o, --output=FILE 输出文件
-s, --silent 关闭警告
--verbose 打印进度信息
-?, --help 给出该系统求助列表
--usage 给出简要的用法信息
-V, --version 打印程序版本号
例子：
iconv -f utf-8 -t gb2312 aaa.txt &gt;bbb.txt
这个命令读取aaa.txt文件，从utf-8编码转换为gb2312编码，其输出定向到bbb.txt文件。
小结：LINUX为我们提供了强大的编码转换工具,给我们带来了方便。
